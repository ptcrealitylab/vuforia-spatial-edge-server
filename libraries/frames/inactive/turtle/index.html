<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="resources/navigation-arrow.js"></script>
    <link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">

    <script src="../sharedResources/threejs-src/2016/three.min.js"></script>
    <script src="../sharedResources/threejs-src/2016/MorphAnimMesh.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/collada/Animation.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/collada/AnimationHandler.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/collada/KeyFrameAnimation.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/sea3d/SEA3D.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/sea3d/SEA3DLZMA.js"></script>
    <script src="../sharedResources/threejs-src/2016/loaders/sea3d/SEA3DLoader.js"></script>
</head>
<body>
<script>
    var camera, scene, renderer;
    
    var loader;

    var threejsContainerObj;
    var realityInterface;
    var turtleObj;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var clock = new THREE.Clock();
    
    var turtleScale = 0.4;
    var scaleIOValue = 1.0;

    window.addEventListener('load', function() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        // Add the turtle to the scene
        turtleObj = new THREE.Object3D();
        threejsContainerObj.add(turtleObj);
        turtleObj.scale.set(turtleScale, turtleScale, turtleScale);
        turtleObj.rotateX(Math.PI/2.0);
        turtleObj.position.setZ(100);
        // SEA3D Loader
        loader = new THREE.SEA3D({
            autoPlay : true, // Auto play animations
            container : turtleObj // Container to add models
        });
        loader.onComplete = function( e ) {
            startAnimation();
        };
        loader.load( 'resources/models/sea3d/mascot.tjs.sea' );

        // light for the scene
        scene.add( new THREE.AmbientLight( 0x333333 ) );

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        realityInterface.setMoveDelay(400);

        // initNavigationArrow(document.querySelector('canvas'), realityInterface, true);

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        realityInterface.registerTouchDecider(function(eventData) {
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera( mouse, camera );

            //3. compute intersections
            var intersects = raycaster.intersectObjects( scene.children, true );

            return intersects.length > 0;
        });

    });

    function startAnimation() {
        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update models with newest values from hybrid object
            var newTurtleScale = turtleScale * scaleIOValue;
            turtleObj.scale.set(newTurtleScale, newTurtleScale, newTurtleScale);
            
            // update model view matrix
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            
            // update SEA3D Animations
            var delta = clock.getDelta();
            THREE.SEA3D.AnimationHandler.update( delta );
            THREE.AnimationHandler.update( delta );
            
            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }

</script>
</body>
</html>
