<!DOCTYPE html>
<html lang="en">
<head>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="objectDefaultFiles/envelopeContents.js"></script>
    <meta charset="UTF-8">
    <title>two sided limiter</title>
    <style>
        body {
            /*background-color: #4E4E4F;*/
        }
        #limiter {
            position: absolute;
            top: 300px;
            width: 780px;
        }
        #touchpadMaxLimit {
            position: absolute;
            left: 525px;
            top: 20px;
            width: 260px;
            height: 260px;
        }
        #touchpadMinLimit {
            position: absolute;
            left: 525px;
            top: 400px;
            width: 260px;
            height: 260px;
        }
        .unselectable {
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body style="width: 859px; height: 1200px">
<svg id="limiter" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 252.3 259.73">
    <defs>
        <style>
            .handleFont {
                font-family: "Avenir", "Futura", Helvetica Neue, Helvetica, Arial, sans-serif;
                font-size: 6pt;
                alignment: right;
                fill: #fed003;
            }

            @font-face {
                font-family: 'Brutal Type';
                src: url('../../sharedResources/fonts/brutal/BrutalType.otf');
                font-weight: normal;
                font-style: normal;
            }
            @font-face {
                font-family: 'Brutal Type';
                src: url('../../sharedResources/fonts/brutal/BrutalType-Bold.otf');
                font-weight: bold;
                font-style: normal;
            }

            .dataFont {
                font-family: BrutalType-Bold, Brutal Type, "Avenir", "Futura", Helvetica Neue, Helvetica, Arial, sans-serif;
                font-size: 12pt;
                alignment: right;
                font-weight: bold;
                fill: white;
            }

            .datatypeFont {
                font-family: BrutalType-Bold, Brutal Type, "Avenir", "Futura", Helvetica Neue, Helvetica, Arial, sans-serif;
                font-size: 12pt;
                alignment: right;
                fill: cyan;
            }

            .cls-1 {
                opacity: 0.5;
            }

            .cls-2 {
                opacity: 0.25;
            }

            .cls-3 {
                fill: #00ffe6;
            }

            .cls-4 {
                fill: #fff;
            }

            .cls-5 {
                fill: lime;
            }

            .green-fill {
                fill: lime;
            }

            .cls-6 {
                fill: #feff00;
            }

            .red-fill {
                fill: #FF007D;
            }

            .handleFont {
                font-family: BrutalType-Bold, Brutal Type, "Avenir", "Futura", Helvetica Neue, Helvetica, Arial, sans-serif;
                font-size: 12pt;
                alignment: right;
                fill: #feff00;
            }
        </style>
    </defs>
    <title>progress-with-fill</title>
    <g id="Layer_2" data-name="Layer 2">
        <g id="UI">
            <g>
                <g>
                    <g class="cls-1">
                        <rect x="3" y="3" width="149.3" height="207.62"/>
                    </g>
                    <g class="cls-2">
                        <path class="cls-3" d="M149.14,6.17V207.46H6.17V6.17h143m3.33-3.34H2.83v208H152.47V2.83Z"/>
                    </g>
                </g>
                <g class="cls-2">
                    <rect class="cls-4" x="13.34" y="154.93" width="128.31" height="43.74"/>
                </g>
                <g class="cls-2">
                    <rect class="cls-4" x="13.34" y="108.27" width="128.31" height="43.74"/>
                </g>
                <g class="cls-2">
                    <rect class="cls-4" x="13.34" y="61.61" width="128.31" height="43.74"/>
                </g>
                <g class="cls-2">
                    <rect class="cls-4" x="13.34" y="14.96" width="128.31" height="43.74"/>
                </g>
                <g class="cls-1">
                    <polygon points="1.31 218.51 1.31 259.73 22.89 259.73 110.72 259.73 110.72 240.09 110.72 218.51 1.31 218.51"/>
                </g>
                <path class="cls-3" d="M107.23,222v34.22H4.81V222H107.23m3.5-3.5H1.31v41.22H110.73V218.51Z"/>
                <g class="cls-1">
                    <rect x="113.64" y="218.51" width="40.03" height="41.21"/>
                </g>
                <path class="cls-3" d="M150.17,222v34.22h-33V222h33m3.5-3.5h-40v41.22h40V218.51Z"/>
                <path class="cls-3" d="M152.3,3V210.62H3V3H152.3m3-3H0V213.62H155.3V0Z"/>

                <g id="box4-green" class="cls-0">
                    <rect class="cls-5" x="13.34" y="154.93" width="128.31" height="43.74"/>
                </g>
                <g id="box3-green" class="cls-0">
                    <rect class="cls-5" x="13.34" y="108.27" width="128.31" height="43.74"/>
                </g>
                <g id="box2-green" class="cls-0">
                    <rect class="cls-5" x="13.34" y="61.61" width="128.31" height="43.74"/>
                </g>
                <g id="box1-green" class="cls-0">
                    <rect class="cls-5" x="13.34" y="14.96" width="128.31" height="43.74"/>
                </g>
            </g>
            <g>
                <g id="labelText">
                    <text class="dataFont" id="dataValue" x="18" y="245">00.000</text>
                    <text class="datatypeFont" id="dataUnit" x="128" y="245">lb</text>
                </g>
            </g>
        </g>
    </g>

    <g id="Layer_3" data-name="Layer 3">
        <g id="limitMax">
            <g>
                <g id="handleMax" class="cls-2">
                    <rect x="170.56" width="81.65" height="23.33"/>
                </g>
                <g id="handleText">
                    <text class="handleFont unselectable" id="handleValue" x="179" y="19">0.000</text>
                </g>
                <g id="bar">
                    <rect class="cls-6" x="14.21" y="11.08" width="150.05" height="1.17"/>
                    <rect class="cls-6" x="13.34" y="5.98" width="1.75" height="11.37"/>
                    <rect class="cls-6" x="158.49" y="5.89" width="11.55" height="11.55"/>
                </g>
            </g>
        </g>
        <g id="limitMin">
            <g>
                <g id="handleMin" class="cls-2">
                    <rect x="170.56" width="81.65" height="23.33"/>
                </g>
                <g id="handleMinText">
                    <text class="handleFont unselectable" id="handleMinValue" x="179" y="18">0.000</text>
                </g>
                <g id="barMin">
                    <rect class="cls-6" x="14.21" y="11.08" width="150.05" height="1.17"/>
                    <rect class="cls-6" x="13.34" y="5.98" width="1.75" height="11.37"/>
                    <rect class="cls-6" x="158.49" y="5.89" width="11.55" height="11.55"/>
                </g>
            </g>
        </g>
    </g>
</svg>

<svg id="touchpadMaxLimit" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116 116">
    <defs>
        <style>
            .touchpad-1 {
                opacity: 0.25;
            }

            .touchpad-2 {
                fill: black;
            }

            .touchpad-3 {
                fill: #feff00;
            }

            .touchpad-4 {
                opacity: 0.5;
            }
        </style>
    </defs>
    <title>Touch Pad</title>
    <g id="Layer_2" data-name="Layer 2">
        <g id="UI">
            <g>
                <g class="touchpad-1">
                    <rect class="touchpad-2" x="2" y="2" width="112" height="112" rx="5"/>
                </g>
                <path class="touchpad-3" d="M109.06,116H99.85v-4H109Zm-18.37,0H81.54v-4h9.15Zm-18.3,0H63.23v-4h9.16Zm-18.31,0H44.92v-4h9.16Zm-18.31,0H26.62v-4h9.15Zm-18.31,0H8.31v-4h9.15ZM0,109V99.86H4V109Zm116-1.37h-4V98.49h4ZM4,90.71H0V81.55H4Zm112-1.37h-4V80.18h4ZM4,72.4H0V63.25H4ZM116,71h-4V61.88h4ZM4,54.09H0V44.94H4Zm112-1.37h-4V43.57h4ZM4,35.79H0V26.63H4Zm112-1.37h-4V25.26h4ZM4,17.48H0V8.33H4Zm112-1.37h-4V7l4,0ZM107.66,4H98.51V0h9.15ZM89.35,4H80.2V0h9.15ZM71,4H61.89V0H71ZM52.74,4H43.58V0h9.16ZM34.43,4H25.28V0h9.15ZM16.12,4H7L7,0h9.15Z"/>
            </g>
            <g class="touchpad-4">
                <path class="touchpad-3" d="M58,93.5A35.5,35.5,0,1,1,93.5,58,35.54,35.54,0,0,1,58,93.5Zm0-70A34.5,34.5,0,1,0,92.5,58,34.54,34.54,0,0,0,58,23.5Z"/>
            </g>
            <path class="touchpad-3" d="M58,74A16,16,0,1,1,74,58,16,16,0,0,1,58,74Zm0-30A14,14,0,1,0,72,58,14,14,0,0,0,58,44Z"/>
        </g>
    </g>
</svg>

<svg id="touchpadMinLimit" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 116 116">
    <title>Touch Pad</title>
    <g id="Layer_2" data-name="Layer 2">
        <g id="UI">
            <g>
                <g class="touchpad-1">
                    <rect class="touchpad-2" x="2" y="2" width="112" height="112" rx="5"/>
                </g>
                <path class="touchpad-3" d="M109.06,116H99.85v-4H109Zm-18.37,0H81.54v-4h9.15Zm-18.3,0H63.23v-4h9.16Zm-18.31,0H44.92v-4h9.16Zm-18.31,0H26.62v-4h9.15Zm-18.31,0H8.31v-4h9.15ZM0,109V99.86H4V109Zm116-1.37h-4V98.49h4ZM4,90.71H0V81.55H4Zm112-1.37h-4V80.18h4ZM4,72.4H0V63.25H4ZM116,71h-4V61.88h4ZM4,54.09H0V44.94H4Zm112-1.37h-4V43.57h4ZM4,35.79H0V26.63H4Zm112-1.37h-4V25.26h4ZM4,17.48H0V8.33H4Zm112-1.37h-4V7l4,0ZM107.66,4H98.51V0h9.15ZM89.35,4H80.2V0h9.15ZM71,4H61.89V0H71ZM52.74,4H43.58V0h9.16ZM34.43,4H25.28V0h9.15ZM16.12,4H7L7,0h9.15Z"/>
            </g>
            <g class="touchpad-4">
                <path class="touchpad-3" d="M58,93.5A35.5,35.5,0,1,1,93.5,58,35.54,35.54,0,0,1,58,93.5Zm0-70A34.5,34.5,0,1,0,92.5,58,34.54,34.54,0,0,0,58,23.5Z"/>
            </g>
            <path class="touchpad-3" d="M58,74A16,16,0,1,1,74,58,16,16,0,0,1,58,74Zm0-30A14,14,0,1,0,72,58,14,14,0,0,0,58,44Z"/>
        </g>
    </g>
</svg>


<script>

    var properties = {
        value: 0,
        unitMax: 1,
        unitMin: 0,
        unit: ""
    };
    var limits = {
        max: 1,
        min: 0
    };

    var boxes = [
        document.getElementById('box4'),
        document.getElementById('box3'),
        document.getElementById('box2'),
        document.getElementById('box1')
    ];
    var greenBoxes = [
        document.getElementById('box4-green'),
        document.getElementById('box3-green'),
        document.getElementById('box2-green'),
        document.getElementById('box1-green')
    ];

    var boxPositionsY = greenBoxes.map(function(svgElement) {
        return parseFloat(svgElement.children[0].getAttribute('y'));
    });

    var boxHeights = greenBoxes.map(function(svgElement) {
        return parseFloat(svgElement.children[0].getAttribute('height'));
    });

    var dataValueText = document.getElementById('dataValue');
    var dataUnitText = document.getElementById('dataUnit');

    function render(value) {
        value = Math.max(0, Math.min(1, value));
        var newHeight;

        // adjust the height of the top-most green region
        if (value < 0.75) {
            greenBoxes[3].style.visibility = 'hidden';
        } else {
            greenBoxes[3].style.visibility = 'visible';
            newHeight = boxHeights[3] * (value - 0.75)/0.25;
            greenBoxes[3].children[0].setAttribute('height', newHeight);
            greenBoxes[3].children[0].setAttribute('y', boxPositionsY[3] + (boxHeights[3] - newHeight));
        }

        // adjust the height of the second green region
        if (value < 0.5) {
            greenBoxes[2].style.visibility = 'hidden';
        } else {
            greenBoxes[2].style.visibility = 'visible';
            newHeight = boxHeights[2] * (Math.min(0.75, value) - 0.5)/0.25;
            greenBoxes[2].children[0].setAttribute('height', newHeight);
            greenBoxes[2].children[0].setAttribute('y', boxPositionsY[2] + (boxHeights[2] - newHeight));
        }

        // adjust the height of the third green region
        if (value < 0.25) {
            greenBoxes[1].style.visibility = 'hidden';
        } else {
            greenBoxes[1].style.visibility = 'visible';
            newHeight = boxHeights[1] * (Math.min(0.5, value) - 0.25)/0.25;
            greenBoxes[1].children[0].setAttribute('height', newHeight);
            greenBoxes[1].children[0].setAttribute('y', boxPositionsY[1] + (boxHeights[1] - newHeight));
        }

        // adjust the height of the bottom green region
        greenBoxes[0].style.visibility = 'visible';
        newHeight = boxHeights[0] * Math.min(0.25, value)/0.25;
        greenBoxes[0].children[0].setAttribute('height', newHeight);
        greenBoxes[0].children[0].setAttribute('y', boxPositionsY[0] + (boxHeights[0] - newHeight));

        // render the text labels
        dataValueText.textContent = numberToText(value).valueText;
        dataUnitText.textContent = numberToText(value).unitText;

        styleBasedOnLimits();
    }

    // scales the raw value from [0,1] range to [unitMin,unitMax] range
    function scaleVal(number) {
        return (number * (properties.unitMax - properties.unitMin)) + properties.unitMin;
    }

    // outputs the text for the value and unit labels, given a raw data value
    function numberToText(value) {
        return {
            valueText: scaleVal(value).toPrecision(4).substring(0, 6),
            unitText: properties.unit
        }
    }

    // custom code for limiter, in addition to the above code which is identical to the progress frame
    var limitMax = document.getElementById('limitMax');
    var touchpadMaxLimit = document.getElementById('touchpadMaxLimit');
    var handleValueText = document.getElementById('handleValue');
    var limitMaxOffsets = {};
    var isMouseDown = false;
    var lastHandleSelected = null;
    var centeredOffsetY = 8.13; //-28; //8.13;

    var limitMin = document.getElementById('limitMin');
    var touchpadMinLimit = document.getElementById('touchpadMinLimit');
    var handleMinValueText = document.getElementById('handleMinValue');

    var svgViewBox = {
        x: document.querySelector('svg').getAttribute('viewBox').split(' ')[0],
        y: document.querySelector('svg').getAttribute('viewBox').split(' ')[1],
        width: document.querySelector('svg').getAttribute('viewBox').split(' ')[2],
        height: document.querySelector('svg').getAttribute('viewBox').split(' ')[3]
    };

    var svgClientRect = document.querySelector('svg').getClientRects()[0];

    function recurseThruSvgElement(svgElement, callback) {
        if (svgElement.tagName === 'g' || svgElement.tagName === 'svg') {
            [].slice.call(svgElement.children).forEach(function(childElement) {
                recurseThruSvgElement(childElement, callback);
            });
        } else {
            callback(svgElement);
        }
    }

    function buildOffsetsLookup(svgElement) {
        // builds up the limitMaxOffsets
        recurseThruSvgElement(svgElement, function(svgElement) {
            console.log('found child: ' + svgElement);
            if (svgElement.tagName === 'rect' || svgElement.tagName === 'text') {
                if (!svgElement.id) { svgElement.id = 'rect' + Math.random(); }
                limitMaxOffsets[svgElement.id] = {
                    y: svgElement.getAttribute('y') ? svgElement.getAttribute('y') : "0"
                }
            }
        });
    }

    buildOffsetsLookup(limitMax);
    buildOffsetsLookup(limitMin);

    function setGroupY(svgElement, yOffset) {
        recurseThruSvgElement(svgElement, function(childElement) {
            if (childElement.tagName === 'rect' || childElement.tagName === 'text') {
                var startY = parseInt(limitMaxOffsets[childElement.id].y);
                var newY = startY + yOffset;
                childElement.setAttribute('y', newY);
            }
        });
    }

    touchpadMaxLimit.addEventListener('pointerdown', function(e) {
        isMouseDown = true;
        lastHandleSelected = 'max';
        console.log(lastHandleSelected);
    });

    touchpadMinLimit.addEventListener('pointerdown', function(e) {
        isMouseDown = true;
        lastHandleSelected = 'min';
        console.log(lastHandleSelected);
    });

    document.getElementById('limiter').addEventListener('pointerdown', function(e) {
        isMouseDown = true;
        lastHandleSelected = 'max';
        console.log(lastHandleSelected);
    });

    document.addEventListener('pointerup', onPointerUp);
    document.addEventListener('pointercancel', onPointerUp);

    function onPointerUp(e) {
        try {
            if (lastHandleSelected === 'max') {
                realityInterface.writePublicData("in_out", "max",  limits.max);
                console.log('write public data for max');
            } else if (lastHandleSelected === 'min') {
                realityInterface.writePublicData("in_out", "min",  limits.min);
                console.log('write public data for min');
            }
        } catch (e) {
            console.warn('Reality Interface is not accessible');
        }

        isMouseDown = false;
        lastHandleSelected = null;
    }

    var maxSvgY = -3;
    var minSvgY = 133.22;

    var y141 = 195; //183.69; //141.35; // the height in SVG units between top and bottom of the four boxes
    // var y28 = 28;

    var svgTop = 4;

    document.addEventListener('pointermove', function(e) {
        if (!isMouseDown) { return; }

        var mouseY = e.pageY - 300;

        if (isNaN(mouseY)) { return; }

        if (lastHandleSelected === 'max') {

            // move handle/limiter bar
            var svgMouseY = mouseY * (svgViewBox.height / svgClientRect.height) + 28; //centeredOffsetY;
            svgMouseY = Math.max(svgTop, Math.min(y141-centeredOffsetY, svgMouseY));

            maxSvgY = svgMouseY;
            if (maxSvgY > minSvgY) {
                maxSvgY = minSvgY;
            }
            setGroupY(limitMax, maxSvgY);

            // update limit value
            limits.max = 1 - (maxSvgY - svgTop) / ((y141-centeredOffsetY - svgTop));

            console.log(limits.max);

        } else if (lastHandleSelected === 'min') {

            // move handle/limiter bar
            var svgMouseY = mouseY * (svgViewBox.height / svgClientRect.height) - 52; //centeredOffsetY;
            svgMouseY = Math.max(svgTop, Math.min(y141-centeredOffsetY, svgMouseY));

            minSvgY = svgMouseY;
            if (minSvgY < maxSvgY) {
                minSvgY = maxSvgY;
            }
            setGroupY(limitMin, minSvgY);

            // update limit value
            limits.min = 1 - (minSvgY - svgTop) / ((y141-centeredOffsetY - svgTop));
        }

        renderTouchpadAndHandle(lastHandleSelected);

        // update colors
        render(properties.value);
    });

    var pxHeight = 560;
    var y20 = 20;
    var y370 = 420;

    function renderTouchpadAndHandle(minOrMax) {
        if (minOrMax === 'max') {
            // move touchpad
            touchpadMaxLimit.style.top = y20 + (1 - limits.max) * pxHeight + 'px';

            // update handle text
            handleValueText.textContent = numberToText(limits.max).valueText + ' ' + numberToText(limits.max).unitText;

        } else if (minOrMax === 'min') {
            // move touchpad
            touchpadMinLimit.style.top = y370 + (1 - limits.min) * pxHeight + 'px';
            // update handle text
            handleMinValueText.textContent = numberToText(limits.min).valueText + ' ' + numberToText(limits.min).unitText;
        }
    }

    function renderLimit() {
        // move max handle
        var percentageDown = 1 - Math.max(0, Math.min(1, limits.max));
        var y = svgTop + (y141-centeredOffsetY-svgTop) * percentageDown;
        setGroupY(limitMax, y);
        renderTouchpadAndHandle('max');

        // move min handle
        percentageDown = 1 - Math.max(0, Math.min(1, limits.min));
        y = svgTop + (y141-centeredOffsetY-svgTop) * percentageDown;
        setGroupY(limitMin, y);
        renderTouchpadAndHandle('min');

        // update colors
        render(properties.value);
    }

    renderLimit();

    function styleBasedOnLimits() {
        if (properties.value >= limits.max || properties.value <= limits.min) {
            greenBoxes.forEach(function(greenBox) {
                if (!greenBox.children[0].classList.contains('red-fill')) {
                    greenBox.children[0].classList.add('red-fill');
                }
            });
        } else {
            greenBoxes.forEach(function(greenBox) {
                if (greenBox.children[0].classList.contains('red-fill')) {
                    greenBox.children[0].classList.remove('red-fill');
                }
            });
        }
    }

    try {
        // set up and load the reality interface
        var realityInterface = new RealityInterface();
        var _envelopeContents = new EnvelopeContents(realityInterface, document.body);
        realityInterface.addReadListener('in_out', function (e) {
            properties.value = e.value;
            if (e.unit) {
                properties.unit = e.unit;
            } else {
                properties.unit = "";
            }
            properties.unitMax = e.unitMax;
            properties.unitMin = e.unitMin;
            render(properties.value);
        });

        realityInterface.addReadPublicDataListener('in_out', "max", function (e) {
            console.log('read in_out max');
            if (!isMouseDown) {
                limits.max = Math.max(e, limits.min);
                renderLimit();
            }
        });

        realityInterface.addReadPublicDataListener('in_out', "min", function (e) {
            console.log('read in_out min');

            if (!isMouseDown) {
                limits.min = Math.min(e, limits.max);
                renderLimit();
            }
        });

        realityInterface.subscribeToMatrix();
        realityInterface.addMatrixListener(function(modelView, projection) {
            var scaleFactor = Math.abs(modelView[0]);
            var zDistance = Math.abs(modelView[14]);
            if (zDistance/scaleFactor > 950*1.5) { // found this to be a good distance through trial and error // todo: switch back to 950, but needs to be bigger for the desktop demo
                // hide the touch pad
                touchpadMaxLimit.style.visibility = 'hidden';
                touchpadMinLimit.style.visibility = 'hidden';
            } else {
                // show the touch pad
                touchpadMaxLimit.style.visibility = '';
                touchpadMinLimit.style.visibility = '';
            }
        });

        realityInterface.setMoveDelay(1000);
        realityInterface.enableCustomInteractionMode();
        // this can also be done without the API by manually giving these divs the class 'realityInteraction'
        realityInterface.setInteractableDivs([touchpadMaxLimit, touchpadMinLimit, document.getElementById('limiter')]);

        realityInterface.onRealityInterfaceLoaded(function() {
            realityInterface.changeFrameSize(800, 1300); // adjust the touch overlay of the iframe to match contents
        });

    } catch (e) {
        console.warn('Reality Interface is not accessible');

        // test suite for in-browser simulation without loading in AR
        function mockListenerTrigger(e) {
            properties.value = e;
            render(properties.value);
        }

        function mockMaxPublicDataListenerTrigger(e) {
            if (!isMouseDown) {
                limits.max = Math.max(e, limits.min);
                renderLimit();
            }
        }

        function mockMinPublicDataListenerTrigger(e) {
            if (!isMouseDown) {
                limits.min = Math.min(e, limits.max);
                renderLimit();
            }
        }
    }


</script>

</body>
</html>
