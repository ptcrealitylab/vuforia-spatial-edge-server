<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Memory Frame</title>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="objectDefaultFiles/object.js"></script>
    <!--<script src="resources/navigation-arrow.js"></script>-->
    <link rel="stylesheet" type="text/css" href="resources/index.css">

    <style>
        #memoryBackground {
            width: 568px;
            height: 320px;
        }

        #memoryErrorMessage {
            width: 568px;
            height: 320px;
            position: absolute;
            left: 0;
            top: 0;
            background-color: black;
            text-align: center;
            /*line-height: 320px;*/
            font-size: 32px;
            padding-top: 50px;
        }
    </style>
</head>
<body>
<!--<img src="resources/memoryThumbnail.jpg" id="memoryBackground">-->

<img id="memoryBackground">
<div id="GUI" style="width: 568px; height: 320px; position: absolute; left: 0; top: 0"></div>

<script>

    var httpPort = 8080;
    var globalDOMCache = {};
    var globalStates = {
        height: 568,
        width: 320
    };

    var objects = {};
    var thisObject = null;

    var guiState = 'ui';

    // var objects = {
    //     stoneTestrmix4u3rq5ve: loadObject()
    // };

    // var rotateX = [
    //     1, 0, 0, 0,
    //     0, -1, 0, 0,
    //     0, 0, 1, 0,
    //     0, 0, 0, 1
    // ];

    // var correctFinalMatrix = 'matrix3d(1142.2231042876606, 50.32578190734703, -0.321185792723156, -0.32054406350801395, -40.74027157031397, 1156.0583867544315, 0.0944623948221826, 0.09427365895695178, -185.87539875815094, 54.325118634052416, -1.9767189113411823, -1.9727694269484346, -16161.616737392527, -3551.742106967751, 1167.067291186871, 1025.110953637076)';

    var realityInterface = new RealityInterface();

    // var waitingForMemory = true;

    var memoryInformation = null;
    var errorMessage = null;

    window.addEventListener('message', function(msg) {
        // console.log('memory frame received message', msg);
        if (typeof msg.data === 'string') {
            var msgData = JSON.parse(msg.data);

            if (typeof msgData.guiState !== 'undefined') {
                console.log('new memory gui state = ' + msgData.guiState);
                if (guiState !== msgData.guiState) {
                    guiState = msgData.guiState;
                    if (thisObject) {
                        renderOnce(thisObject, guiState);
                    }
                }
            }

            // if (typeof msgData.getNodesAndLinks !== 'undefined') {
            //     postNodesAndLinksToParent();
            // }

        }
    });

    function postNodesAndLinksToParent() {
        var nodePositions = calculateNodePositions();
        var links = getLinks();
        parent.postMessage(JSON.stringify({
            memoryMessage: {
                objectID: thisObject.objectId,
                nodes: nodePositions,
                links: links
            }
        }), '*');
    }

    realityInterface.onRealityInterfaceLoaded(function() {
        console.log('memory frame loaded for realityObject', realityObject);

        realityInterface.setMoveDelay(10);

        realityInterface.addReadPublicDataListener('storage', 'memoryInformation', function(msgContents) {
            // console.log('---- MEMORY FRAME RECEIVED PUBLIC DATA ----', msg);

            if (!memoryInformation) {

                if (typeof msgContents === 'string') {
                    msgContents = JSON.parse(msgContents);
                }

                memoryInformation = msgContents;

                if (errorMessage) {
                    errorMessage.parentElement.removeChild(errorMessage);
                    errorMessage = null;
                }

                // if (typeof memoryInformation !== 'undefined') {
                    console.log('---- memory frame received memoryInformation ----', memoryInformation);

                    // waitingForMemory = false;

                    getData('http://' + memoryInformation.objectIP + ':' + httpPort + '/object/' + memoryInformation.objectID, function (object) {

                        // renderOnce(objects.stoneTestrmix4u3rq5ve);
                        console.log('downloaded object', object);

                        var isBackwardCompatibleMemory = typeof object.memory.matrix !== 'undefined';

                        if ((isBackwardCompatibleMemory && Object.keys(object.memory.matrix).length === 16) ||
                            !isBackwardCompatibleMemory && Object.keys(object.memory).length === 16) {

                            console.log('successfully loaded memory for object ' + memoryInformation.objectID);

                            thisObject = object;
                            objects[memoryInformation.objectID] = object; // TODO: not actually necessary right now to use objects dictionary in this iframe

                            var memoryUrl = 'http://' + memoryInformation.objectIP + ':' + httpPort + '/obj/' + object.name + '/memory/memoryThumbnail.jpg';
                            document.getElementById('memoryBackground').src = memoryUrl;

                            renderOnce(object, guiState);

                        } else {
                            // failed if can't find a 4x4 matrix in object.memory or object.memory.matrix

                            console.log('failed loading memory for object ' + memoryInformation.objectID);

                            memoryInformation = null; // reset so it can try to download again later

                            errorMessage = document.createElement('div');
                            errorMessage.id = 'memoryErrorMessage';
                            errorMessage.innerHTML = 'Memory for object<br>' + object.name + '<br>doesn\'t exist.<br><br>Please create one and try again.';
                            document.body.appendChild(errorMessage);

                        }

                    });
                // }

            }

        });

    });

    function getData(url, callback) {
        var req = new XMLHttpRequest();
        try {
            req.open('GET', url, true);
            // Just like regular ol' XHR
            req.onreadystatechange = function () {
                if (req.readyState === 4) {
                    if (req.status === 200) {
                        // JSON.parse(req.responseText) etc.
                        if (req.responseText)
                            callback(JSON.parse(req.responseText));
                    } else {
                        // Handle error case
                        console.log("could not load content");
                        // _this.cout("could not load content");
                    }
                }
            };
            req.send();
        }
        catch (e) {
            this.cout("could not connect to" + url);
        }
    }


    /**
     * @param {Object} object
     * @param {string} guiState
     */
    function renderOnce(object, guiState) {

        var visibleObjectMatrix = object.memory || newIdentityMatrix();

        // backwards compatibility with old memory structure
        if (typeof object.memory.matrix !== 'undefined' && Object.keys(object.memory.matrix).length === 16) {
            visibleObjectMatrix = object.memory.matrix;
        }

        var correctedCameraMatrix = object.memoryCameraMatrix || newIdentityMatrix();
        var projectionMatrix = object.memoryProjectionMatrix || getProjectionMatrix(); //getProjectionMatrix();

        var activeObjectMatrix = [];
        var modelViewMatrix = [];
        var modelViewProjectionMatrix = [];
        // multiplyMatrix(rotateX, visibleObjectMatrix, activeObjectMatrix);
        // multiplyMatrix(activeObjectMatrix, correctedCameraMatrix, modelViewMatrix);
        // multiplyMatrix(modelViewMatrix, projectionMatrix, modelViewProjectionMatrix);

        // multiplyMatrix(rotateX, visibleObjectMatrix, activeObjectMatrix);
        multiplyMatrix(visibleObjectMatrix, projectionMatrix, modelViewProjectionMatrix);

        for (var frameKey in object.frames) {
            var activeFrame = object.frames[frameKey];

            // for now, don't recursively render memoryFrames
            if (activeFrame.src === 'memoryFrame') { continue; }

            if (guiState === 'ui') {

                // TODO: add some CSS to all 'nodexxxx' divs to hide them entirely
                hideNodes();
                unhideFrames();

                // if a DOM element hasn't been added for this frame yet, add it and load the correct src into an iframe
                if (!globalDOMCache['object' + frameKey]) {
                    var frameUrl = "http://" + object.ip + ":" + httpPort + "/obj/" + object.name + "/frames/" + activeFrame.name + "/";
                    addElement(frameUrl, object.objectId, frameKey, null, 'ui', activeFrame);
                }

                console.log(globalDOMCache['object' + frameKey]);

                var positionData = activeFrame.ar;
                var finalOffsetX = positionData.x;
                var finalOffsetY = positionData.y;
                var finalScale = positionData.scale;

                var repositionMatrix = [
                    finalScale, 0, 0, 0,
                    0, finalScale, 0, 0,
                    0, 0, 1, 0,
                    finalOffsetX, finalOffsetY, 0, 1
                ];

                if (!positionData.matrix || positionData.matrix.length !== 16) {
                    positionData.matrix = newIdentityMatrix();
                }

                var framePositionMatrix = [];
                var finalMatrix = [];
                multiplyMatrix(positionData.matrix, modelViewProjectionMatrix, framePositionMatrix);
                multiplyMatrix(repositionMatrix, framePositionMatrix, finalMatrix);

                globalDOMCache['object' + frameKey].style.transform = 'matrix3d(' + finalMatrix.toString() + ')';

            } else if (guiState === 'node') {

                // TODO: add some CSS to all 'framexxxx' divs to make them semi-transparent
                hideFrames();
                unhideNodes();

                for (var nodeKey in activeFrame.nodes) {

                    var activeNode = activeFrame.nodes[nodeKey];

                    // if a DOM element hasn't been added for this node yet, add it and load the correct src into an iframe
                    if (!globalDOMCache['object' + nodeKey]) {

                        var nodeUrl = "http://" + object.ip + ":" + httpPort + "/nodes/" + activeNode.type + "/index.html";
                        addElement(nodeUrl, object.objectId, frameKey, nodeKey, activeNode.type, activeNode);
                    }

                    console.log(globalDOMCache['object' + nodeKey]);

                    var positionData = activeFrame.ar;
                    var finalOffsetX = positionData.x + activeNode.x;
                    var finalOffsetY = positionData.y + activeNode.y;
                    var finalScale = positionData.scale * activeNode.scale;

                    var repositionMatrix = [
                        finalScale, 0, 0, 0,
                        0, finalScale, 0, 0,
                        0, 0, 1, 0,
                        finalOffsetX, finalOffsetY, 0, 1
                    ];

                    if (!positionData.matrix || positionData.matrix.length !== 16) {
                        positionData.matrix = newIdentityMatrix();
                    }

                    var framePositionMatrix = [];
                    var finalMatrix = [];
                    multiplyMatrix(positionData.matrix, modelViewProjectionMatrix, framePositionMatrix);
                    multiplyMatrix(repositionMatrix, framePositionMatrix, finalMatrix);

                    globalDOMCache['object' + nodeKey].style.transform = 'matrix3d(' + finalMatrix.toString() + ')';

                }

            }

        }

        if (guiState === 'node') {
            postNodesAndLinksToParent();
        }

    }

    function calculateNodePositions() {
        var positions = {};
        var allNodeDivs = [].slice.call(document.getElementById('GUI').querySelectorAll('.nodeContainer'));
        allNodeDivs.forEach(function(nodeContainerDiv) {
            var rect = nodeContainerDiv.getClientRects()[0];
            var centerPosition = {
                x: rect.x + rect.width/2,
                y: rect.y + rect.height/2
            };
            centerPosition.percentX = centerPosition.x / window.innerWidth;
            centerPosition.percentY = centerPosition.y / window.innerHeight;
            var nodeKey = nodeContainerDiv.id.replace(/^(object)/,'');
            positions[nodeKey] = centerPosition;
        });
        return positions;
    }

    function getLinks() {
        var allLinks = {};
        for (var frameKey in thisObject.frames) {
            var thisFrame = thisObject.frames[frameKey];
            for (var linkKey in thisFrame.links) {
                allLinks[linkKey] = thisFrame.links[linkKey];
            }
        }
        return allLinks;
    }

    function hideFrames() {
        var allFrameDivs = [].slice.call(document.getElementById('GUI').querySelectorAll('.frameContainer'));
        allFrameDivs.forEach(function(frameContainerDiv) {
            frameContainerDiv.classList.add('hiddenFrame');
        });
    }

    function unhideFrames() {
        var allFrameDivs = [].slice.call(document.getElementById('GUI').querySelectorAll('.frameContainer'));
        allFrameDivs.forEach(function(frameContainerDiv) {
            frameContainerDiv.classList.remove('hiddenFrame');
        });
    }

    function hideNodes() {
        var allNodeDivs = [].slice.call(document.getElementById('GUI').querySelectorAll('.nodeContainer'));
        allNodeDivs.forEach(function(nodeContainerDiv) {
            nodeContainerDiv.classList.add('hiddenNode');
        });
    }

    function unhideNodes() {
        var allNodeDivs = [].slice.call(document.getElementById('GUI').querySelectorAll('.nodeContainer'));
        allNodeDivs.forEach(function(nodeContainerDiv) {
            nodeContainerDiv.classList.remove('hiddenNode');
        });
    }

    /**
     * If needed, creates the DOM element for a given frame or node
     * Can be safely called multiple times for the same element (knows to ignore if its already been loaded)
     * @param {string} thisUrl - the iframe src url
     * @param {string} objectKey
     * @param {string} frameKey
     * @param {string} nodeKey
     * @param {string} activeType - 'ui', 'node', 'logic', etc, to tag the element with
     * @param {Frame|Node} activeVehicle - reference to the frame or node to create.
     *                                     it's properties are used to instantiate the correct DOM element.
     */
    function addElement(thisUrl, objectKey, frameKey, nodeKey, activeType, activeVehicle) {
        var activeKey = (!!nodeKey) ? nodeKey : frameKey;
        var isFrameElement = activeKey === frameKey;

        // if (this.notLoading !== true && this.notLoading !== activeKey && activeVehicle.loaded !== true) {

            console.log("loading " + objectKey + "/" + frameKey + "/" + (nodeKey||"null"));

            // this.notLoading = activeKey;

            // assign the element some default properties if they don't exist
            if (typeof activeVehicle.frameSizeX === 'undefined') {
                activeVehicle.frameSizeX = activeVehicle.width || 220;
            }
            if (typeof activeVehicle.width === 'undefined') {
                activeVehicle.width = activeVehicle.frameSizeX;
            }
            if (typeof activeVehicle.frameSizeY === 'undefined') {
                activeVehicle.frameSizeY = activeVehicle.height || 220;
            }
            if (typeof activeVehicle.height === 'undefined') {
                activeVehicle.height = activeVehicle.frameSizeY;
            }
            if (typeof activeVehicle.begin !== "object") {
                activeVehicle.begin = newIdentityMatrix();
            }
            if (typeof activeVehicle.temp !== "object") {
                activeVehicle.temp = newIdentityMatrix();
            }
            activeVehicle.animationScale = 0;
            activeVehicle.loaded = true;
            activeVehicle.visibleEditing = false;

            // determine if the frame should be loaded locally or from the server (by default thisUrl points to server)
            if (/*isFrameElement &&*/ activeVehicle.location === 'global') {
                // thisUrl = 'frames/' + activeVehicle.src + '.html'; // loads the frame locally from the /frames/ directory
                if (isFrameElement) {
                    thisUrl = 'http://' + objects[objectKey].ip + ':' + httpPort + '/frames/' + activeVehicle.src + '.html';
                } else {
                    thisUrl = 'http://' + objects[objectKey].ip + ':' + httpPort + '/nodes/' + activeVehicle.type + '/index.html';
                }
            }

            // Create DOM elements for everything associated with this frame/node
            var domElements = createSubElements(thisUrl, objectKey, frameKey, nodeKey, activeVehicle);
            var addContainer = domElements.addContainer;
            // addContainer.style.border = '5px solid red';
            var addIframe = domElements.addIframe;
            var addOverlay = domElements.addOverlay;
            var addSVG = domElements.addSVG;
            // var addDistanceUI = domElements.addDistanceUI;

            addOverlay.objectId = objectKey;
            addOverlay.frameId = frameKey;
            addOverlay.nodeId = nodeKey;
            addOverlay.type = activeType;

            // todo the event handlers need to be bound to non animated ui elements for fast movements.
            // todo the lines need to end at the center of the square.

            if (activeType === "logic") {

                // add the 4-quadrant animated SVG overlay for the logic nodes
                var addLogic = this.createLogicElement(activeVehicle, activeKey);
                addOverlay.appendChild(addLogic);
                globalDOMCache["logic" + activeKey] = addLogic;
            }

            // append all the created elements to the DOM in the correct order...
            document.getElementById("GUI").appendChild(addContainer);
            addContainer.appendChild(addIframe);
            addContainer.appendChild(addOverlay);
            addOverlay.appendChild(addSVG);
            // document.getElementById("GUI").appendChild(addDistanceUI);
            // addOverlay.appendChild(addDistanceUI);

            // cache references to these elements to more efficiently retrieve them in the future
            globalDOMCache[addContainer.id] = addContainer;
            globalDOMCache[addIframe.id] = addIframe;
            globalDOMCache[addOverlay.id] = addOverlay;
            globalDOMCache[addSVG.id] = addSVG;

            // add touch event listeners
            // realityEditor.device.addTouchListenersForElement(addOverlay, activeVehicle);
        // }
    }

    /**
     * Instantiates the many different DOM elements that make up a frame or node.
     *      addContainer - holds all the different pieces of this element
     *      addIframe - loads in the content for this frame, e.g. a graph or three.js scene, or a node graphic
     *      addOverlay - an invisible overlay that catches touch events and passes into the iframe if needed
     *      addSVG - a visual feedback image that displays when you are dragging the element around
     * @param {string} iframeSrc
     * @param {string} objectKey
     * @param {string} frameKey
     * @param {string} nodeKey
     * @param {Frame|Node} activeVehicle
     * @return {{addContainer: HTMLDivElement, addIframe: HTMLIFrameElement, addOverlay: HTMLDivElement, addSVG: HTMLElement, addDistanceUI: HTMLElement}}
     */
    var createSubElements = function(iframeSrc, objectKey, frameKey, nodeKey, activeVehicle) {

        var activeKey = (!!nodeKey) ? nodeKey : frameKey;

        var addContainer = document.createElement('div');
        addContainer.id = "object" + activeKey;
        addContainer.className = "main";
        addContainer.style.width = globalStates.height + "px";
        addContainer.style.height = globalStates.width + "px";
        if (!!nodeKey) { // if this is a node
            addContainer.classList.add('nodeContainer');
        } else {
            addContainer.classList.add('frameContainer');
        }
        addContainer.style.border = 0;
        addContainer.classList.add('ignorePointerEvents'); // don't let invisible background from container intercept touches

        var addIframe = document.createElement('iframe');
        addIframe.id = "iframe" + activeKey;
        addIframe.className = "main";
        addIframe.frameBorder = 0;
        addIframe.style.width = (activeVehicle.width || activeVehicle.frameSizeX) + "px";
        addIframe.style.height = (activeVehicle.height || activeVehicle.frameSizeY) + "px";
        addIframe.style.left = ((globalStates.height - activeVehicle.frameSizeX) / 2) + "px";
        addIframe.style.top = ((globalStates.width - activeVehicle.frameSizeY) / 2) + "px";
        // addIframe.classList.add('hiddenFrame');
        addIframe.src = iframeSrc;
        addIframe.setAttribute("data-frame-key", frameKey);
        addIframe.setAttribute("data-object-key", objectKey);
        addIframe.setAttribute("data-node-key", nodeKey);
        addIframe.setAttribute("onload", 'onElementLoad("' + objectKey + '","' + frameKey + '","' + nodeKey + '")');
        addIframe.setAttribute("sandbox", "allow-forms allow-pointer-lock allow-same-origin allow-scripts");
        addIframe.classList.add('usePointerEvents'); // override parent (addContainer) pointerEvents value

        var addOverlay = document.createElement('div');
        addOverlay.id = activeKey;
        addOverlay.className = (globalStates.editingMode && activeVehicle.developer) ? "mainEditing" : "mainProgram";
        addOverlay.frameBorder = 0;
        addOverlay.style.width = activeVehicle.frameSizeX + "px";
        addOverlay.style.height = activeVehicle.frameSizeY + "px";
        addOverlay.style.left = ((globalStates.height - activeVehicle.frameSizeX) / 2) + "px";
        addOverlay.style.top = ((globalStates.width - activeVehicle.frameSizeY) / 2) + "px";
        addOverlay.style.visibility = "hidden";
        addOverlay.style.zIndex = "3";
        if (activeVehicle.developer) {
            addOverlay.style["touch-action"] = "none";
        }
        addOverlay.classList.add('usePointerEvents'); // override parent (addContainer) pointerEvents value

        var addSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        addSVG.id = "svg" + activeKey;
        addSVG.className = "mainCanvas";
        addSVG.style.width = "100%";
        addSVG.style.height = "100%";
        addSVG.style.zIndex = "3";
        // addSVG.style.display = 'none';
        addSVG.classList.add('svgDefaultState');
        addSVG.classList.add('usePointerEvents'); // override parent (addContainer) pointerEvents value
        addSVG.setAttribute('shape-rendering','geometricPrecision'); //'optimizeSpeed'

        // var addDistanceUI = document.createElement('div');
        // addDistanceUI.id = 'distance' + activeKey;
        // addDistanceUI.classList.add('main');
        // addDistanceUI.classList.add('distanceUI');

        return {
            addContainer: addContainer,
            addIframe: addIframe,
            addOverlay: addOverlay,
            addSVG: addSVG
            // addDistanceUI: addDistanceUI
        };
    };

    /**
     * Creates the DOM element for a Logic Node
     * @param {Frame|Node} activeVehicle
     * @param {string} activeKey
     * @return {HTMLDivElement}
     */
    function createLogicElement(activeVehicle, activeKey) {
        var size = 200;
        var addLogic = document.createElement('div');
        addLogic.id = "logic" + activeKey;
        addLogic.className = "mainEditing";
        addLogic.style.width = size + "px";
        addLogic.style.height = size + "px";
        addLogic.style.left = 0; //((activeVehicle.frameSizeX - size) / 2) + "px";
        addLogic.style.top = 0; //((activeVehicle.frameSizeY - size) / 2) + "px";
        addLogic.style.visibility = "hidden";

        var svgContainer = document.createElementNS('http://www.w3.org/2000/svg', "svg");
        svgContainer.setAttributeNS(null, "viewBox", "0 0 100 100");

        var svgElement = [];
        svgElement.push(document.createElementNS("http://www.w3.org/2000/svg", "path"));
        svgElement[0].setAttributeNS(null, "fill", "#00ffff");
        svgElement[0].setAttributeNS(null, "d", "M50,0V50H0V30A30,30,0,0,1,30,0Z");
        svgElement.push(document.createElementNS("http://www.w3.org/2000/svg", "path"));
        svgElement[1].setAttributeNS(null, "fill", "#00ff00");
        svgElement[1].setAttributeNS(null, "d", "M100,30V50H50V0H70A30,30,0,0,1,100,30Z");
        svgElement.push(document.createElementNS("http://www.w3.org/2000/svg", "path"));
        svgElement[2].setAttributeNS(null, "fill", "#ffff00");
        svgElement[2].setAttributeNS(null, "d", "M100,50V70a30,30,0,0,1-30,30H50V50Z");
        svgElement.push(document.createElementNS("http://www.w3.org/2000/svg", "path"));
        svgElement[3].setAttributeNS(null, "fill", "#ff007c");
        svgElement[3].setAttributeNS(null, "d", "M50,50v50H30A30,30,0,0,1,0,70V50Z");

        for (var i = 0; i < svgElement.length; i++) {
            svgContainer.appendChild(svgElement[i]);
            svgElement[i].number = i;
            // svgElement[i].addEventListener('pointerenter', function () {
            //     globalProgram.logicSelector = this.number;
            //
            //     if (globalProgram.nodeA === activeKey)
            //         globalProgram.logicA = this.number;
            //     else
            //         globalProgram.logicB = this.number;
            //
            //     console.log(globalProgram.logicSelector);
            // });
            addLogic.appendChild(svgContainer);
        }

        return addLogic;
    };

    function onElementLoad(objectKey, frameKey, nodeKey) {
        console.log('loaded', objectKey, frameKey, nodeKey);

        if (nodeKey === 'null') nodeKey = null;

        var activeKey = nodeKey || frameKey;
        globalDOMCache['iframe' + activeKey].style.visibility = 'visible';
        globalDOMCache[activeKey].style.visibility = 'visible';

        if (nodeKey && guiState !== 'node') {
            globalDOMCache['object' + nodeKey].classList.add('hiddenNode');
        } else if (!nodeKey && guiState !== 'ui') {
            globalDOMCache['object' + frameKey].classList.add('hiddenFrame');
        }


        // realityEditor.gui.ar.draw.notLoading = false;
        //
        // if (nodeKey === "null") nodeKey = null;

        // cout("posting Msg");
        var version = 170;
        var object = objects[objectKey];
        var frame = null;
        if (object) {
            version = object.integerVersion;
            frame = object.frames[frameKey];
        }
        var nodes = (!!frame) ? frame.nodes : {};

        var oldStyle = {
            obj: objectKey,
            pos: nodeKey,
            objectValues: (!!object) ? object.nodes : {},
            interface: globalStates.interface
        };

        var simpleNodes = getNodesJsonForIframes(nodes);

        var newStyle = {
            object: objectKey,
            frame: frameKey,
            objectData: {},
            node: nodeKey,
            nodes: simpleNodes,
            interface: null
        };

        if (version < 170 && objectKey === nodeKey) {
            newStyle = oldStyle;
        }

        if (object && object.ip) {
            newStyle.objectData = {
                ip: object.ip
            };
        }
        var activeKey = nodeKey || frameKey;

        // // if (globalDOMCache['svg' + activeKey]) {
        // //     realityEditor.gui.ar.moveabilityOverlay.createSvg(globalDOMCache['svg' + activeKey]);
        // // }
        //
        globalDOMCache["iframe" + activeKey]._loaded = true;
        globalDOMCache["iframe" + activeKey].contentWindow.postMessage(JSON.stringify(newStyle), '*');

        // if (nodeKey) {
        //     var node = realityEditor.getNode(objectKey, frameKey, nodeKey);
        //     if (node.type === 'logic') {
        //         realityEditor.gui.ar.draw.updateLogicNodeIcon(node);
        //     }
        // }
    }

    // avoids serializing cyclic data structures by only including minimal information needed for node iframe
    // (keys such as grid and links sometimes contain cyclic references)
     function getNodesJsonForIframes(nodes) {
        var simpleNodes = {};
        var keysToExclude = ["links", "blocks", "grid", "guiState"];
        for (var node in nodes) {
            if (!nodes.hasOwnProperty(node)) continue;
            simpleNodes[node] = {};
            for (var key in nodes[node]) {
                if (!nodes[node].hasOwnProperty(key)) continue;
                if (keysToExclude.indexOf(key) === -1) {
                    simpleNodes[node][key] = nodes[node][key];
                }
            }
        }
        return simpleNodes;
    }

    function getProjectionMatrix() {
        var oldProjectionMatrix = [ -1214.857, 0.000, 0.000, 0.000, 0.000, -1214.857, 0.000, 0.000, 5.845, -19.239, 2.004, 2.000, 0.000, 0.000, -4.004, 0.000 ];
        // var oldRealProjectionMatrix = [ -1.651, 0.000, 0.000, 0.000, 0.000, 2.934, 0.000, 0.000, 0.004, 0.023, 1.002, 1.000, 0.000, 0.000, -4.004, 0.000 ];
        var newProjectionMatrix = [-1140.395936, 0, 0, 0, 0, -1140.3961199999999, 0, 0, 4.073024, -8.595468, 2.004004, 2, 0, 0, -4.004004, 0];
        return newProjectionMatrix;
    }

    function loadObject() {

        return JSON.parse("{\"objectId\":\"stoneTestrmix4u3rq5ve\",\"name\":\"stoneTest\",\"ip\":\"10.10.10.109\",\"version\":\"3.1.0\",\"deactivated\":false,\"protocol\":\"R2\",\"tcs\":\"2o6LPC\",\"visible\":false,\"visibleText\":false,\"visibleEditing\":false,\"memory\":[-0.9880483095065227,-0.0728421900055229,-0.13585026435566017,0,0.05879001785290355,-0.9927616034709436,0.1047322703881485,0,0.142495820465779,-0.09549354201547097,-0.985178377649512,0,64.7624112284307,-7.980369677572119,664.8658928307367,1],\"frames\":{\"stoneTestrmix4u3rq5vetest2\":{\"objectId\":\"stoneTestrmix4u3rq5ve\",\"name\":\"test2\",\"visualization\":\"ar\",\"ar\":{\"x\":-100.27439364688743,\"y\":-20.164415936950974,\"scale\":1.0158175176864208,\"matrix\":[0.9989386591438816,-0.005419845564172743,0.04572273606058275,-2.498001805406602e-16,0.00622140274684807,0.9998303211523383,-0.017399069984008197,2.415602440297704e-16,-0.04562177735962791,0.017662554547916542,0.9988032877654405,-7.771561172376096e-16,97.0483669500536,12.628860681886636,9.86478480999358,1.0000000000022737]},\"screen\":{\"x\":0,\"y\":0,\"scale\":1},\"visible\":false,\"visibleText\":false,\"visibleEditing\":false,\"developer\":true,\"links\":{},\"nodes\":{\"stoneTestrmix4u3rq5vetest2testNode\":{\"name\":\"testNode\",\"objectId\":\"stoneTestrmix4u3rq5ve\",\"frameId\":\"stoneTestrmix4u3rq5vetest2\",\"data\":{\"value\":0,\"mode\":\"f\",\"unit\":\"\",\"unitMin\":0,\"unitMax\":1},\"x\":-96,\"y\":-8,\"scale\":1,\"matrix\":[],\"type\":\"storeData\",\"stress\":0,\"privateData\":{},\"publicData\":{\"testData\":\"clientMessage\",\"anotherTestData\":\"clientReceived37\"},\"frameSizeX\":100,\"frameSizeY\":100}},\"location\":\"local\",\"src\":\"editor\",\"privateData\":{},\"publicData\":{},\"staticCopy\":false,\"distanceScale\":1,\"groupID\":null},\"stoneTestrmix4u3rq5veslideraV58f4x4ojc8\":{\"objectId\":\"stoneTestrmix4u3rq5ve\",\"name\":\"slideraV58f4x4ojc8\",\"visualization\":\"ar\",\"ar\":{\"x\":208.857050575340935,\"y\":-21.151664570505744,\"scale\":0.25,\"matrix\":[]},\"screen\":{\"x\":0,\"y\":0,\"scale\":0.5},\"visible\":false,\"visibleText\":false,\"visibleEditing\":false,\"developer\":true,\"links\":{},\"nodes\":{\"stoneTestrmix4u3rq5veslideraV58f4x4ojc8value\":{\"name\":\"value\",\"objectId\":\"stoneTestrmix4u3rq5ve\",\"frameId\":\"stoneTestrmix4u3rq5veslideraV58f4x4ojc8\",\"data\":{\"value\":0,\"mode\":\"f\",\"unit\":\"\",\"unitMin\":0,\"unitMax\":1},\"x\":0,\"y\":0,\"scale\":0.5,\"matrix\":[],\"type\":\"node\",\"src\":\"\",\"stress\":0,\"privateData\":{},\"publicData\":{\"default\":50},\"lockPassword\":null,\"lockType\":null,\"frameSizeX\":220,\"frameSizeY\":220}},\"location\":\"global\",\"src\":\"slider\",\"privateData\":{},\"publicData\":{},\"staticCopy\":false,\"distanceScale\":1,\"groupID\":null,\"uuid\":\"stoneTestrmix4u3rq5veslideraV58f4x4ojc8\",\"width\":\"206\",\"height\":\"526\"}},\"framesHistory\":{},\"visualization\":\"ar\",\"zone\":\"\",\"targetSize\":{\"width\":0.3,\"height\":0.21},\"developer\":true,\"memoryCameraMatrix\":[-0.9951009999999998,-0.0005036371665064869,0.09886225846400877,0,-0.032007826411748014,0.947769,-0.31734747783367595,0,-0.093538755857641,-0.3189571585473581,-0.9431419999999998,0,-47.49579349884051,16.357424773641636,-172.95192639585514,1]}");

        // return {
        //     benIdFrontEP6m1o2lr90g: {
        //         objectId: "benIdFrontEP6m1o2lr90g",
        //         name: "benIdFront",
        //         ip: "10.10.10.110",
        //         version: "3.1.0",
        //         deactivated: false,
        //         protocol: "R2",
        //         tcs: "1md6XY",
        //         visible: false,
        //         visibleText: false,
        //         visibleEditing: false,
        //         memory: {},
        //         memoryCameraMatrix: {},
        //         frames: {
        //             // benIdFrontEP6m1o2lr90gturtle: {
        //             //     objectId: null,
        //             //     name: "turtle",
        //             //     visualization: "ar",
        //             //     ar: {
        //             //         x: 394,
        //             //         y: 32,
        //             //         scale: 1,
        //             //         matrix: []
        //             //     },
        //             //     screen: {
        //             //         x: 0,
        //             //         y: 0,
        //             //         scale: 1
        //             //     },
        //             //     visible: false,
        //             //     visibleText: false,
        //             //     visibleEditing: false,
        //             //     developer: true,
        //             //     links: {},
        //             //     nodes: {
        //             //         benIdFrontEP6m1o2lr90gturtletest1NPes991lp7yr: {
        //             //             name: "test1",
        //             //             objectId: "benIdFrontEP6m1o2lr90g",
        //             //             frameId: "benIdFrontEP6m1o2lr90gturtle",
        //             //             data: {
        //             //                 value: 0,
        //             //                 mode: "f",
        //             //                 unit: "",
        //             //                 unitMin: 0,
        //             //                 unitMax: 1
        //             //             },
        //             //             x: 500,
        //             //             y: 10.714017848596256,
        //             //             scale: 0.5,
        //             //             matrix: [],
        //             //             type: "node",
        //             //             src: "",
        //             //             stress: 0,
        //             //             privateData: {},
        //             //             publicData: {},
        //             //             lockPassword: null,
        //             //             lockType: null,
        //             //             uuid: "benIdFrontEP6m1o2lr90gturtletest1NPes991lp7yr",
        //             //             attachToGroundPlane: true,
        //             //             lastEditor: "um2oujuo"
        //             //         },
        //             //         benIdFrontEP6m1o2lr90gturtletest2eTgcz012mff9: {
        //             //             name: "test2",
        //             //             objectId: "benIdFrontEP6m1o2lr90g",
        //             //             frameId: "benIdFrontEP6m1o2lr90gturtle",
        //             //             data: {
        //             //                 value: 0,
        //             //                 mode: "f",
        //             //                 unit: "",
        //             //                 unitMin: 0,
        //             //                 unitMax: 1
        //             //             },
        //             //             x: -107.80727633855922,
        //             //             y: 500,
        //             //             scale: 0.5,
        //             //             matrix: [],
        //             //             type: "node",
        //             //             src: "",
        //             //             stress: 0,
        //             //             privateData: {},
        //             //             publicData: {},
        //             //             lockPassword: null,
        //             //             lockType: null,
        //             //             uuid: "benIdFrontEP6m1o2lr90gturtletest2eTgcz012mff9",
        //             //             attachToGroundPlane: true,
        //             //             lastEditor: "um2oujuo"
        //             //         }
        //             //     },
        //             //     location: "local",
        //             //     src: "editor",
        //             //     privateData: {},
        //             //     publicData: {},
        //             //     staticCopy: false,
        //             //     distanceScale: 1,
        //             //     groupID: null
        //             // },
        //             benIdFrontEP6m1o2lr90gdefault: {
        //                 objectId: null,
        //                 name: "default",
        //                 visualization: "ar",
        //                 ar: {
        //                     x: 0,
        //                     y: 0,
        //                     scale: 1,
        //                     matrix: []
        //                 },
        //                 screen: {
        //                     x: 0,
        //                     y: 0,
        //                     scale: 1
        //                 },
        //                 visible: false,
        //                 visibleText: false,
        //                 visibleEditing: false,
        //                 developer: true,
        //                 links: {},
        //                 nodes: {},
        //                 location: "local",
        //                 src: "editor",
        //                 privateData: {},
        //                 publicData: {},
        //                 staticCopy: false,
        //                 distanceScale: 1,
        //                 groupID: null
        //             }
        //         },
        //         framesHistory: {},
        //         visualization: "ar",
        //         zone: "",
        //         targetSize: {
        //             width: 0.1,
        //             height: 0.163071
        //         }
        //     }
        // }
    }

    /**
     * @desc This function multiplies one m16 matrix with a second m16 matrix
     * @param {Array.<number>} m2 - origin matrix to be multiplied with
     * @param {Array.<number>} m1 - second matrix that multiplies.
     * @return {Array.<number>} m16 matrix result of the multiplication
     */
    var multiplyMatrix = function(m2, m1, r) {
        // var r = [];
        // Cm1che only the current line of the second mm1trix
        r[0] = m2[0] * m1[0] + m2[1] * m1[4] + m2[2] * m1[8] + m2[3] * m1[12];
        r[1] = m2[0] * m1[1] + m2[1] * m1[5] + m2[2] * m1[9] + m2[3] * m1[13];
        r[2] = m2[0] * m1[2] + m2[1] * m1[6] + m2[2] * m1[10] + m2[3] * m1[14];
        r[3] = m2[0] * m1[3] + m2[1] * m1[7] + m2[2] * m1[11] + m2[3] * m1[15];

        r[4] = m2[4] * m1[0] + m2[5] * m1[4] + m2[6] * m1[8] + m2[7] * m1[12];
        r[5] = m2[4] * m1[1] + m2[5] * m1[5] + m2[6] * m1[9] + m2[7] * m1[13];
        r[6] = m2[4] * m1[2] + m2[5] * m1[6] + m2[6] * m1[10] + m2[7] * m1[14];
        r[7] = m2[4] * m1[3] + m2[5] * m1[7] + m2[6] * m1[11] + m2[7] * m1[15];

        r[8] = m2[8] * m1[0] + m2[9] * m1[4] + m2[10] * m1[8] + m2[11] * m1[12];
        r[9] = m2[8] * m1[1] + m2[9] * m1[5] + m2[10] * m1[9] + m2[11] * m1[13];
        r[10] = m2[8] * m1[2] + m2[9] * m1[6] + m2[10] * m1[10] + m2[11] * m1[14];
        r[11] = m2[8] * m1[3] + m2[9] * m1[7] + m2[10] * m1[11] + m2[11] * m1[15];

        r[12] = m2[12] * m1[0] + m2[13] * m1[4] + m2[14] * m1[8] + m2[15] * m1[12];
        r[13] = m2[12] * m1[1] + m2[13] * m1[5] + m2[14] * m1[9] + m2[15] * m1[13];
        r[14] = m2[12] * m1[2] + m2[13] * m1[6] + m2[14] * m1[10] + m2[15] * m1[14];
        r[15] = m2[12] * m1[3] + m2[13] * m1[7] + m2[14] * m1[11] + m2[15] * m1[15];
        // return r;
    };

    var newIdentityMatrix = function() {
        return [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    }

</script>

</body>
</html>