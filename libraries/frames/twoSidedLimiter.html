<!DOCTYPE html>
<html lang="en">
<head>
    <script src="resources/object-frames.js"></script>
    <script src="resources/pep.min.js"></script>
    <meta charset="UTF-8">
    <title>graph</title>
    <style>
        @font-face {
            font-family: 'Speculum';
            src: url('resources/speculum.ttf');
        }

        #frame {
            stroke: #00ffff;
            stroke-width: 4;
            fill: rgba(0, 255, 255, 0.3);
        }

        .numberOutline {
            stroke-width: 4;
            fill: rgba(0, 0, 0, 0.2);
        }

        #backgroundFrame {
            fill: rgba(51, 51, 51, 0.8);
        }

        .lines {
            stroke-width: 2;
            stroke: rgba(51, 255, 255, 0.4);
        }

        .green {
            fill: rgb(41, 253, 47);
        }

        .greenStroke {
            stroke: rgb(41, 253, 47);
        }

        .red {
            fill: rgb(242, 22, 121);
        }

        .redStroke {
            stroke: rgb(242, 22, 121);

        }

        .overlay {
            fill: rgba(0, 0, 0, 0.3);
        }

        .blue {
            fill: rgb(45, 255, 255);
        }

        .purple {
            fill: rgb(210, 113, 255);
        }

        .yellow {
            fill: rgb(255, 255, 45);

        }

        .yellowStroke {
            stroke: rgb(255, 255, 45);
            fill: rgba(0, 0, 0, 0.2);
        }

        .dataFont {

            font-family: Speculum, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;
            letter-spacing: -6pt;
            font-size: 32pt;
            alignment: right;
            font-stretch: semi-expanded;
            transform: scaleX(0.7);
        }

        .dataFontMiddle {

            font-family: Speculum, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;
            letter-spacing: -4pt;
            fill: #00ffff;
            font-size: 26pt;
            transform: scaleX(0.7);
        }

        .dataFontSmall {

            font-family: Speculum, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;
            fill: #00ffff;
            letter-spacing: -1pt;
            font-size: 12pt;
            alignment: right;
            transform: scaleX(0.7);
        }

    </style>
</head>
<body>
<!--
<div id= "outlineMinShadow" style=" backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
height: 130px; width: 230px; top: 12px;left: 373px; position: fixed;  transform: translateZ(-1px)" >
</div>

<div id= "outlineMaxShadow" style="backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
height: 130px; width: 230px; top: 12px;left: 373px; position: fixed;  transform: translateZ(-1px)" >
</div>
-->
<div id="show" style=" visibility: hidden">

    <svg id="container" width="640" height="600" version="1.1" xmlns="http://www.w3.org/2000/svg" touch-action="none">

        <svg x="20" y="245">
            <rect class="numberOutline redStroke" id="dataValueOutline" x="1" y="1" width="230" height="65" rx="0" ry="0"/>
            <text class="dataFont red" id="dataValue" x="20" y="46">00.000</text>
        </svg>


        <svg x="270" y="145">
            <rect id="frame" x="1" y="1" width="100" height="297" rx="0" ry="0"/>
            <line x1="0" y1="150" x2="100" y2="150" class="lines" stroke-width="1"/>
            <line x1="0" y1="75" x2="100" y2="75" class="lines" stroke-width="1"/>
            <line x1="0" y1="225" x2="100" y2="225" class="lines" stroke-width="1"/>
            <rect id="data" class="green" x="0" y="1" width="103" height="300" rx="0" ry="0"/>

            <rect id="dataOverlayMax" class="overlay" x="0" y="1" width="103" height="150" rx="0" ry="0"/>
            <rect id="dataOverlayMin" class="overlay" x="0" y="1" width="103" height="150" rx="0" ry="0"/>
        </svg>

        <svg x="270" y="380" id="limiterMin">
            <svg x="103" y="0">
                <rect class="numberOutline yellowStroke" id="outlineMin" x="1" y="1" width="230" height="130" rx="0" ry="0"/>
                <text class="dataFont yellow" id="valueMin" x="20" y="77">00.000</text>
            </svg>
            <polygon class="yellow" points="0 0 103 68 103 0 0 0"/>
        </svg>


        <svg x="270" y="12" id="limiterMax">
            <svg x="103" y="0">
                <rect class="numberOutline yellowStroke" id="outlineMax" x="1" y="1" width="230" height="130" rx="0" ry="0"/>
                <text class="dataFont yellow" id="valueMax" x="20" y="77">00.000</text>
            </svg>  <svg x="0" y="65">
            <polygon class="yellow" points="0 68 103 0 103 68 0 68"/>
        </svg>
        </svg>


    </svg>
</div>


<script>
    var realityInterface = new RealityInterface();
    var dataValue = document.querySelector('#dataValue');
    var dataValueOutline = document.querySelector('#dataValueOutline');
    var dataBar = document.querySelector('#data');
    var valueMin = document.querySelector('#valueMin');
    var valueMax = document.querySelector('#valueMax');
    var limiterMin = document.querySelector('#limiterMin');
    var limiterMax = document.querySelector('#limiterMax');

    // var outlineMinShadow = document.querySelector('#outlineMinShadow');
    //  var outlineMaxShadow = document.querySelector('#outlineMaxShadow');

    var screenIsTouched = false;

    var dataOverlayMin = document.querySelector('#dataOverlayMin');
    var dataOverlayMax = document.querySelector('#dataOverlayMax');
    var sliderHeight = 300;
    var limits = {
        min: 0,
        max: 300,
        currentMax: 0,
        currentMin: sliderHeight,

    };
    var properties = {
        value: 0,
        valueOld: 0,
        unitMax: 0,
        unitMin: 0,
        unit: ""
    };
    var time = 20;
    var isReady = false;


    function scaleVal(number) {
        return (number * (properties.unitMax - properties.unitMin)) + properties.unitMin;
    }

    function numberToText(value) {
        return scaleVal(value).toPrecision(5).substring(0, 6) + " " + properties.unit;
    }


    function checkScope() {
        if (properties.value > (sliderHeight - limits.currentMin) / sliderHeight && properties.value < (sliderHeight - limits.currentMax) / sliderHeight) {
            dataValueOutline.setAttribute('class', "numberOutline greenStroke");
            dataValue.setAttribute('class', "dataFont green");
            dataBar.setAttribute('class', "green");
        } else {
            dataValueOutline.setAttribute('class', "numberOutline redStroke");
            dataValue.setAttribute('class', "dataFont red");
            dataBar.setAttribute('class', "red");
        };

        dataOverlayMin.setAttribute('height', sliderHeight - limits.currentMin + "px");
        dataOverlayMin.setAttribute('y', limits.currentMin + "px");

        dataOverlayMax.setAttribute('height', limits.currentMax + "px");
        dataOverlayMax.setAttribute('y', 0 + "px");

    }

    function setMin(pageY){
        var move = pageY;

        if (move <= limits.min + 210) {
            move = limits.min + 210;
        }
        if (move >= limits.max + 210) {
            move = limits.max + 210;
        }
        if (move <= limits.currentMax + 211) {
            move = limits.currentMax + 211;
        }


        limiterMin.setAttribute('y', move - 65 + "px");

        //outlineMinShadow.style.top =  move - 65 + "px";

        limits.currentMin = move - 210;

        valueMin.textContent = numberToText((sliderHeight - limits.currentMin) / sliderHeight);
        checkScope();
    }

    function setMax(pageY){
        var move = pageY;

        if (move <= limits.min + 77) {
            move = limits.min + 77;
        }
        if (move >= limits.max + 77) {
            move = limits.max + 77;
        }

        if (move >= limits.currentMin + 76) {
            move = limits.currentMin + 76;
        }

        limiterMax.setAttribute('y', move - 65 + "px");

        // outlineMaxShadow.style.top =  move - 65 + "px";

        limits.currentMax = move - 77;
        valueMax.textContent = numberToText((sliderHeight - limits.currentMax) / sliderHeight);
        checkScope();
    }


    limiterMin.addEventListener("pointermove",
        function (event) {
            screenIsTouched = true;
            setMin(event.clientY);
            realityInterface.writePublicData("in_out", "min",  1-limits.currentMin/sliderHeight);
        }, false);


    limiterMax.addEventListener("pointermove",
        function (event) {
            screenIsTouched = true;
            setMax(event.clientY);
            realityInterface.writePublicData("in_out", "max",  1-limits.currentMax/sliderHeight);
        }, false);

    limiterMin.addEventListener("pointerdown",
        function (event) {
            screenIsTouched = true;
            setMin(event.clientY);
            realityInterface.writePublicData("in_out", "min",  1-limits.currentMin/sliderHeight);
        }, false);


    limiterMax.addEventListener("pointerdown",
        function (event) {
            screenIsTouched = true;
            setMax(event.clientY);
            realityInterface.writePublicData("in_out", "max",  1-limits.currentMax/sliderHeight);
        }, false);



    limiterMin.addEventListener("pointerup",
        function (event) {
            screenIsTouched = false;
        }, false);


    limiterMax.addEventListener("pointerup",
        function (event) {
            screenIsTouched = false;
        }, false);




    function renderProperties() {
        if (!isReady) {
            return;
        }

        checkScope();


        if (properties.value <= 0) {
            properties.value = 0;
        }
        if (properties.value >= 1) {
            properties.value = 1;
        }

        var heightCalculation = properties.value * sliderHeight;

        dataBar.setAttribute('height', heightCalculation + "px");
        dataBar.setAttribute('y', sliderHeight - heightCalculation + "px");


        dataValue.textContent = numberToText(properties.value);


    }

    function ready() {
        isReady = true;
        renderProperties();
    }

    ready();

    setInterval(function () {
        renderProperties();
    }, time);


    realityInterface.addReadListener('in_out', function (e) {

        properties.value = e.value;
        if(e.unit) {
            properties.unit = e.unit;
        } else {
            properties.unit = "";
        }
        properties.unitMax = e.unitMax;
        properties.unitMin = e.unitMin;
        // console.log(e);
    });

    properties.value = 0.01;
    properties.unitMax = 100;
    properties.unitMin = 0;
    properties.unit = "";

    realityInterface.addReadPublicDataListener('in_out', "min", function (e) {
        if(screenIsTouched === false) {
            limits.currentMin = 98 + ((1 - e) * 300);
            setMin(limits.currentMin + 112);
        }
    });

    realityInterface.addReadPublicDataListener('in_out', "max", function (e) {
        if(screenIsTouched === false) {
            limits.currentMax = ((1 - e) * 300) - 35;
            setMax(limits.currentMax + 112);
        }
        document.querySelector('#show').style.visibility = "visible";
    });

    realityInterface.setMoveDelay(1000);
    //  {value: 0.4565680618804775, mode: "f", unit: "volt", unitMin: 300, unitMax: 0}
</script>
</body>
</html>
